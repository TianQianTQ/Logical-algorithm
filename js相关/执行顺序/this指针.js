/** * 题一 */var a = 1;function fn() {    var a = 2;    console.log(this.a);    this.a = 3;    console.log(this);    console.log(this.a);}fn();var s = new fn();//  a this.a 此处的this指向s新对象的内部，内部并没有a,故返回undefined// 1  3  undefined  3/** * 题二 * this指向和arguments对象 */var length = 10;function fn() {    console.log(this.length);}var obj = {    length: 5,    method: function (fn) {        fn();        arguments[0]();    }}obj.method(fn, 1);//  10    2// 解析：首先把fn放在obj的method函数下引用，此时引用相当于function fn(),并没有绑定上下文，fn是作为普通函数的，故this指向全局  10//      arguments[0]指实参数组，即[ function fn(){console.log..} , 1 ]，this指这个数组，故this.length 为2/** * 题三 * */function fn() {    console.log(this.a);}var obj = {    a: 2,    fn: fn   // 声明方式}obj.fn();   //2// 解析：fn加上obj的引用，相当于绑定了上下文，this值指向obj/** * 题四 */function fn() {    console.log(this.a);}var obj = {    a: 2,    fn: fn}var bar = obj.fn; //函数别名bar();//undefined// 解析：虽然bar是obj.fn的一个引用，但实际上引用的是fn本身，故此时bar()是一个不带参数的函数调用，故返回undefined/** * 题五 */function fn(){    console.log(this.a);}var obj = {    a:2,    fn:fn}var a = "global";setTimeout(obj.fn,100);//  globalfunction setTimeout(fn,delay){    //等待delay毫秒    fn();//调用位置}// 解析：放置在setTimeout中，引用的是fn本身，故此处this指向全局/** * 题六 */function fn(){    console.log(this.a);}var a = 2;var o = { a:3,fn:fn};var p = { a:4}o.fn();(p.fn = o.fn)();//   3    2/** * 总结：分析这种隐式绑定的原则：如果在一个对象内包含一个指向函数的属性，并通过这个属性间接引用函数，只有在这种情况下的this才会绑定到这个对象上。 */var name = 'jay';var person = {    name:'kang',    pro:{        name:'Michael',        getName:function(){            return this.name;        }    }}console.log(person.pro.getName());   //  Michaelvar people = person.pro.getName;console.log(people());  //  jay