/** * 浅复制：只复制一份引用，所有的引用都指向同一份数据，并且都可以修改这份数据 * 深复制：实现真正意义上的数组和对象的拷贝（重新找一个内存存储） * 常见的简单数据类型是深复制   let a = 10,b = a; * 引用类型牵扯深复制 */function Clone(obj){    var buf;    if(obj instanceof Array){        buf = [];        var i = obj.length;        while(i--){            buf[i] = Clone(obj[i]);        }        return buf;    } else if(obj instanceof Object){        buf = {};        for(var k in obj){            buf[k] = obj[k];        }        return buf;    }    else{        return obj;    }}function deepClone (target, option){    if(option){        var copy,src;        for(var prop in option){            //罗列出option的属性名            copy = option[prop];            //罗列出target的属性名用于对比copy值是否已经有了一样的名称。            src = target[prop];            //判断是引用值还是原始值            if(copy && typeof copy == 'object'){                //判断引用值是数组还是对象                if(Object.prototype.toString.call(copy) == '[object Array]'){                    //如果target本身就有这个属性名那就用自己的属性名，如果没有就创建一个空数组用于存放属性值。                    src = src ? src : [];                }else{                    src = src ? src : {};                }                //用递归函数层层渗透解析，一直到原始值。                target[prop] = deepClone(src, copy);            }else{                target[prop] = copy;            }        }    }    return target;}//所谓深度克隆，就是当对象的某个属性值为object或array的时候，要获得一份copy，而不是直接拿到引用值function deepClone(origin,target) {  //origin是被克隆对象，target是我们获得copy    var target = target || {}; //定义target    for(var key in origin) {  //遍历原对象        if(origin.hasOwnProperty(key)) {            if(Array.isArray(origin[key])) { //如果是数组                target[key] = [];                deepClone(origin[key],target[key]) //递归            } else if (typeof origin[key] === 'object' && origin[key] !== null) {                target[key] = {};                deepClone(origin[key],target[key]) //递归            }            target[key] = origin[key];        }    }    return target;}